"""
Задание "Слишком древний шифр":

Перед вами появились ворота (выход из ловушки) с двумя каменными вставками для чисел.
В первом поле камни с числом менялись постоянно (от 3 до 20) случайным образом, а второе было всегда пустым.
Во вторую вставку нужно было написать те пары чисел друг за другом, чтобы число из первой вставки было кратно (делилось без остатка) сумме их значений.
Пример:
9 - число из первой вставки
1218273645 - нужный пароль (1 и 2, 1 и 8, 2 и 7, 3 и 6, 4 и 5 - пары; число 9 кратно сумме каждой пары)

Составьте алгоритм, используя циклы, чтобы в независимости от введённого числа n (от 3 до 20) программа выдавала нужный пароль result, для одного введённого числа.

Все пароли для чисел от 3 до 20 (для сверки):
3 - 12
4 - 13
5 - 1423
6 - 121524
7 - 162534
8 - 13172635
9 - 1218273645
10 - 141923283746
11 - 11029384756123
12 - 12131511124210394857
13 - 112211310495dfg867
14 - 1611325212343114105968
15 - 1214114232133124115106978
16 - 1317115262143531341251161079
17 - 11621531441351261171089
18 - 12151811724272163631545414513612711810
19 - 118217316415514613712811910
20 - 13141911923282183731746416515614713812911

Примечания:
Можно использовать как цикл for, так и цикл while
Пары чисел подбираются от 1 до 20 для текущего числа.
Пары являются уникальными
"""

# Решение:

n = int(input("Введите число n (от 3 до 20): "))	

def cypher() :
#	print("Ok")
	cypher_var = []
	pair_numbers = []
	for i in range(1, 21):			
		for j in range(1, 21):
			if n % (i + j) == 0 and i != j and set(pair_numbers) not in cypher_var :
#				cypher_var = [i, j]	
				pair_numbers.append(i)
				pair_numbers.append(j)
				cypher_var.append(pair_numbers)

	
#	if set(pair_numbers) not in cypher_var :
		
#	return(cypher_var)
#	print(n, "-", *cypher_var)
	print(n, "-", *pair_numbers)
#				print(n, "-", i, j)
	


if n >= 3 and n <= 20 :
	cypher()
else:
	print("Введенное число n выходит за пределы диапазона от 3 до 20")
